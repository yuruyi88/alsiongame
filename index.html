<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Voldemort ‚Äì V2 (Mobile + Items)</title>
  <style>
    :root{
      --fg:#fff; --bg:#111; --panel:#1b1b1d; --border:#3c3c40;
      --good:#22c55e; --bad:#ef4444;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
    #wrap{position:relative;max-width:100vw;margin:0 auto;}
    #hud{display:flex;gap:8px;align-items:center;justify-content:center;padding:6px 8px}
    .bar{flex:1;max-width:240px;height:14px;background:#2a2a2f;border-radius:8px;overflow:hidden;border:1px solid var(--border)}
    .fill{height:100%;background:linear-gradient(90deg,var(--good),#16a34a)}
    .enemy{background:linear-gradient(90deg,var(--bad),#b91c1c)}

    /* Canvas scales to screen width while internal resolution stays fixed */
    #stage{position:relative;margin:0 auto;border:2px solid var(--border);border-radius:12px;overflow:hidden;background:var(--panel)}
    canvas{display:block;width:100%;height:auto;}

    /* Mobile control overlay */
    .mobile-controls{position:absolute;bottom:10px;right:10px;display:flex;gap:8px;align-items:end;pointer-events:none}
    .power-stack{display:grid;grid-template-columns:repeat(1,1fr);gap:6px;pointer-events:auto}
    .chip{background:#26262b;border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:14px;min-width:90px;text-align:center}
    .chip.active{outline:2px solid #e11d48}
    .fire-btn{pointer-events:auto;background:#0e7490;border:1px solid #155e75;border-radius:999px;font-size:16px;padding:12px 16px;min-width:92px}

    /* Start button row (outside canvas for desktop) */
    #top-controls{display:flex;gap:8px;justify-content:center;align-items:center;padding:8px}
    button{color:#fff;cursor:pointer}

    /* Small screens tweaks */
    @media (max-width:600px){
      .chip{min-width:72px;font-size:13px;padding:6px 8px}
      .fire-btn{min-width:80px;padding:10px 14px}
      .bar{max-width:180px}
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="hud">
      <div class="bar"><div id="hpYou" class="fill" style="width:100%"></div></div>
      <div class="bar"><div id="hpE" class="fill enemy" style="width:100%"></div></div>
    </div>
    <div id="top-controls">
      <span id="powerLabel">Power: <b>Laser</b></span>
      <button id="startBtn">Start</button>
      <button id="restartBtn" style="display:none">Restart</button>
    </div>

    <div id="stage" style="max-width: min(100vw, 900px);">
      <canvas id="game" width="860" height="520"></canvas>
      <!-- Mobile overlay controls (lower-right) -->
      <div class="mobile-controls">
        <div class="power-stack" id="powerStack">
          <button class="chip active" data-power="laser">üî¥ Laser</button>
          <button class="chip" data-power="ice">üßä Ice</button>
          <button class="chip" data-power="fire">üî• Fire</button>
          <button class="chip" data-power="invis">ü´• Invisible</button>
          <button class="chip" data-power="karate">ü•ã Karate</button>
        </div>
        <button id="fireBtn" class="fire-btn">FIRE</button>
      </div>
    </div>
  </div>

<script>
// ===== Setup
const c = document.getElementById('game');
const ctx = c.getContext('2d');
const hpYou = document.getElementById('hpYou');
const hpE = document.getElementById('hpE');
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');
const powerLabel = document.getElementById('powerLabel');
const powerStack = document.getElementById('powerStack');
const fireBtn = document.getElementById('fireBtn');

// Base speeds
const playerBaseSpeed = 0.3;     // px/ms
const enemyBaseSpeed  = 0.12;    // px/ms
const projectileSpeed = 0.12;    // px/ms for laser/fire/ice-ball

// Game state
let started=false, running=false; let startAt=0; const START_GRACE=1500; let lastAnim=0;
const powers = ['laser','ice','fire','invis','karate'];
let powerIndex=0; let currentPower=powers[powerIndex];

const player={x:100,y:300,w:44,h:64,color:'#4af',hp:100,face:1,inv:false,invT:0,stunT:0,speed:playerBaseSpeed,nextHitAt:0,clickTarget:null};
const enemy ={x:680,y:300,w:54,h:74,color:'#000',hp:100,face:-1,fxFreeze:0,stunT:0,burnT:0,speed:enemyBaseSpeed};

let projectiles=[]; // {type,x,y,vx,vy,ttl,beamLen}
let items=[];       // apples: {kind:'apple',x,y,r}
let hazards=[];     // hammers: {kind:'hammer',x,y,w,h,vy}

let nextAppleAt=0, nextHammerAt=0;

// ===== Input
const keys={};
window.addEventListener('keydown',e=>{
  if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' ','0','w','a','s','d','W','A','S','D'].includes(e.key)) e.preventDefault();
  keys[e.key]=true;
  if(e.key===' ' && started && running) activatePower();
  if(e.key==='0') cyclePower();
});
window.addEventListener('keyup',e=>{ keys[e.key]=false; });

function cyclePower(){
  powerIndex=(powerIndex+1)%powers.length; setPower(powers[powerIndex]);
}
function setPower(p){ currentPower=p; powerIndex=powers.indexOf(p); updatePowerUI(); }
function updatePowerUI(){
  [...powerStack.querySelectorAll('.chip')].forEach((btn,i)=>{
    btn.classList.toggle('active', powers[i]===currentPower);
  });
  powerLabel.innerHTML = 'Power: <b>'+currentPower.charAt(0).toUpperCase()+currentPower.slice(1)+'</b>';
}

powerStack.querySelectorAll('.chip').forEach(btn=>{
  btn.addEventListener('click',()=>{ setPower(btn.dataset.power); });
});
fireBtn.addEventListener('click',()=>{ if(started && running) activatePower(); });
startBtn.addEventListener('click',()=> reset(true));
restartBtn.addEventListener('click',()=> reset(true));

// Click / touch to move toward point
function canvasPoint(ev){
  const rect=c.getBoundingClientRect();
  const x=(ev.clientX-rect.left)*(c.width/rect.width);
  const y=(ev.clientY-rect.top)*(c.height/rect.height);
  return {x,y};
}
['mousedown','touchstart'].forEach(evt=>{
  c.addEventListener(evt,(e)=>{
    if(!(started&&running)) return;
    const ref = e.touches? e.touches[0] : e;
    const p = canvasPoint(ref);
    player.clickTarget=p; e.preventDefault();
  }, {passive:false});
});

// ===== Helpers
function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }
function rectsOverlap(a,b){ return !(a.x+a.w<b.x||a.x>b.x+b.w||a.y+a.h<b.y||a.y> b.y+b.h); }
function circleHitsRect(cx,cy,cr, r){
  const closestX = clamp(cx, r.x, r.x+r.w);
  const closestY = clamp(cy, r.y, r.y+r.h);
  const dx=cx-closestX, dy=cy-closestY; return (dx*dx+dy*dy) <= cr*cr;
}
function overlayMsg(msg){
  ctx.save(); ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(0,0,c.width,c.height); ctx.restore();
  ctx.fillStyle='#fff'; ctx.font='bold 28px system-ui'; ctx.textAlign='center'; ctx.fillText(msg, c.width/2, c.height/2);
}
function randRange(a,b){ return a + Math.random()*(b-a); }

// ===== Spawning
function scheduleApple(now){ nextAppleAt = now + randRange(5000,10000); }
function scheduleHammer(now){ nextHammerAt = now + randRange(6000,11000); }

// ===== Draw
function draw(){
  ctx.clearRect(0,0,c.width,c.height);
  // background pattern
  ctx.fillStyle='#141416'; ctx.fillRect(0,0,c.width,c.height);
  ctx.strokeStyle='#0b0b0d'; ctx.setLineDash([6,10]); ctx.beginPath(); for(let y=60;y<c.height;y+=40){ctx.moveTo(0,y);ctx.lineTo(c.width,y);} ctx.stroke(); ctx.setLineDash([]);
  // wall stickers
  ctx.font='18px system-ui'; ctx.globalAlpha=.8; const dogs=['üêï','üêï‚Äçü¶∫','üê∂']; for(let i=0;i<8;i++){ ctx.fillText(dogs[i%3], 40+i*95, 40+(i%2)*28); } ctx.globalAlpha=1;

  // items (apples)
  for(const it of items){ if(it.kind==='apple'){ ctx.fillStyle='#22c55e'; ctx.beginPath(); ctx.arc(it.x,it.y,it.r,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#14532d'; ctx.fillRect(it.x-1, it.y-it.r-6, 2, 6); }}
  // hazards (hammers)
  for(const hz of hazards){ if(hz.kind==='hammer'){ ctx.fillStyle='#eab308'; ctx.fillRect(hz.x, hz.y, hz.w, hz.h); ctx.fillStyle='#78350f'; ctx.fillRect(hz.x+hz.w*0.35, hz.y-10, hz.w*0.3, 10); }}

  // player & enemy
  drawCharacter(player,'YOU','#4af', player.stunT>0);
  drawVoldemort(enemy, enemy.fxFreeze>0 || enemy.stunT>0);

  // projectiles
  for(const p of projectiles){
    if(p.type==='laser'){
      const d = Math.hypot(p.vx,p.vy)||1; const ux=p.vx/d, uy=p.vy/d; const L=p.beamLen;
      ctx.strokeStyle = 'rgba(239,68,68,.9)'; ctx.lineWidth = 2 + Math.sin(performance.now()/60)*0.7;
      ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x + ux*L, p.y + uy*L); ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,.6)'; ctx.lineWidth = 1.2; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x + ux*L*0.9, p.y + uy*L*0.9); ctx.stroke();
    } else if(p.type==='fire' || p.type==='iceball'){
      ctx.fillStyle = (p.type==='fire') ? 'orange' : '#60a5fa';
      ctx.beginPath(); ctx.arc(p.x,p.y,7,0,Math.PI*2); ctx.fill();
    } else if(p.type==='karate'){
      ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(p.x-6,p.y); ctx.lineTo(p.x+6,p.y); ctx.stroke();
    }
  }

  if(!started){ overlayMsg('Click Start to Play'); }
}

function drawCharacter(o,label,base, stunned=false){
  ctx.save();
  ctx.fillStyle=base; ctx.fillRect(o.x,o.y,o.w,o.h);
  ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.strokeRect(o.x,o.y,o.w,o.h);
  // head
  ctx.fillStyle='#ffd166'; ctx.fillRect(o.x+o.w/2-8,o.y-12,16,12);
  // label
  ctx.fillStyle='#fff'; ctx.font='14px system-ui'; ctx.textAlign='center'; ctx.fillText(label,o.x+o.w/2,o.y-16);
  // inv shimmer
  if(o.inv){ ctx.strokeStyle='rgba(255,255,255,.8)'; ctx.strokeRect(o.x-3,o.y-15,o.w+6,o.h+18); }
  // stun stars
  if(stunned){ ctx.fillStyle='#fde68a'; ctx.fillText('‚≠ê', o.x+o.w/2-12, o.y-24); ctx.fillText('‚≠ê', o.x+o.w/2+6, o.y-30); }
  ctx.restore();
}

function drawVoldemort(e, dim=false){
  ctx.save();
  ctx.fillStyle = dim? '#161618' : '#0a0a0b';
  ctx.fillRect(e.x,e.y,e.w,e.h);
  ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.strokeRect(e.x,e.y,e.w,e.h);
  ctx.fillStyle='#e5e7eb'; ctx.fillRect(e.x+e.w/2-10,e.y-14,20,14);
  ctx.fillStyle='#111'; ctx.fillRect(e.x+e.w/2-6,e.y-8,3,2); ctx.fillRect(e.x+e.w/2+3,e.y-8,3,2);
  ctx.strokeStyle='#111'; ctx.beginPath(); ctx.arc(e.x+e.w/2,e.y-3,5,0,Math.PI); ctx.stroke();
  ctx.fillStyle='#e11d48'; ctx.beginPath(); for(let i=0;i<6;i++){ const ang=i*Math.PI/3; const px=e.x+14+Math.cos(ang)*6; const py=e.y+16+Math.sin(ang)*6; ctx.ellipse(px,py,4,2,ang,0,Math.PI*2); } ctx.fill();
  ctx.fillStyle='#16a34a'; ctx.fillRect(e.x+14, e.y+20, 2, 6);
  ctx.fillStyle='#fff'; ctx.font='14px system-ui'; ctx.textAlign='center'; ctx.fillText('VOLDEMORT', e.x+e.w/2, e.y-16);
  if(e.fxFreeze>0){ ctx.fillStyle='rgba(59,130,246,.25)'; ctx.fillRect(e.x-3,e.y-15,e.w+6,e.h+18); }
  ctx.restore();
}

// ===== Update
function update(dt){
  draw();
  if(!started) return; if(!running) return;
  const now=performance.now();

  // Spawn timers
  if(now>=nextAppleAt){ items.push({kind:'apple', x: randRange(40,c.width-40), y: randRange(80,c.height-40), r:10}); scheduleApple(now); }
  if(now>=nextHammerAt){ hazards.push({kind:'hammer', x: randRange(20,c.width-30), y:-20, w:24, h:18, vy: playerBaseSpeed*0.8 }); scheduleHammer(now); }

  // Movement vectors
  const left = keys['ArrowLeft']||keys['a']||keys['A'];
  const right= keys['ArrowRight']||keys['d']||keys['D'];
  const up   = keys['ArrowUp']||keys['w']||keys['W'];
  const down = keys['ArrowDown']||keys['s']||keys['S'];
  let vx=(right?1:0)-(left?1:0), vy=(down?1:0)-(up?1:0);

  // Click move
  if(player.clickTarget){
    const dx=player.clickTarget.x-(player.x+player.w/2);
    const dy=player.clickTarget.y-(player.y+player.h/2);
    const d=Math.hypot(dx,dy);
    if(d<6){ player.clickTarget=null; }
    else { vx=dx/d; vy=dy/d; }
  }

  // Apply stun
  if(player.stunT>0){ player.stunT-=dt; vx=0; vy=0; }
  if(enemy.stunT>0){ enemy.stunT-=dt; }

  const mag=Math.hypot(vx,vy)||1; player.x+= (vx/mag)*player.speed*dt; player.y+= (vy/mag)*player.speed*dt;
  player.x=clamp(player.x,10,c.width-10-player.w); player.y=clamp(player.y,40,c.height-10-player.h);
  if(vx!==0) player.face = vx>0?1:-1;

  // inv timer
  if(player.inv){ player.invT-=dt; if(player.invT<=0){ player.inv=false; }}

  // enemy AI: chase unless frozen/stunned
  if(enemy.fxFreeze>0){ enemy.fxFreeze-=dt; }
  else if(enemy.stunT>0){ /* stunned: don't move */ }
  else {
    const dx=(player.x-enemy.x), dy=(player.y-enemy.y); const d=Math.hypot(dx,dy)||1;
    enemy.x += (dx/d) * enemy.speed * dt;
    enemy.y += (dy/d) * enemy.speed * dt;
  }
  enemy.x=clamp(enemy.x,10,c.width-10-enemy.w); enemy.y=clamp(enemy.y,40,c.height-10-enemy.h);

  // Items: apples eat
  for(let i=items.length-1;i>=0;i--){ const it=items[i];
    if(it.kind==='apple'){
      if(circleHitsRect(it.x,it.y,it.r, player)){ items.splice(i,1); player.hp=Math.min(100, player.hp+15); continue; }
      if(circleHitsRect(it.x,it.y,it.r, enemy )){ items.splice(i,1); enemy.hp =Math.min(100, enemy.hp +15); continue; }
    }
  }

  // Hazards: hammers drop & stun on hit
  for(let i=hazards.length-1;i>=0;i--){ const hz=hazards[i]; if(hz.kind!=='hammer') continue; hz.y += hz.vy*dt;
    const rect={x:hz.x,y:hz.y,w:hz.w,h:hz.h};
    if(rectsOverlap(rect, player)){ player.stunT=Math.max(player.stunT, 1000); hazards.splice(i,1); continue; }
    if(rectsOverlap(rect, enemy )){ enemy.stunT =Math.max(enemy.stunT, 1000); hazards.splice(i,1); continue; }
    if(hz.y>c.height+40){ hazards.splice(i,1); }
  }

  // contact damage
  if(rectsOverlap(player,enemy)){
    if(now-startAt>START_GRACE && now>=player.nextHitAt && !player.inv){
      damagePlayer(8); player.nextHitAt = now + 600; // rate limit
    }
  }

  // Projectiles
  for(let i=projectiles.length-1;i>=0;i--){
    const p=projectiles[i]; p.ttl-=dt; if(p.ttl<=0){ projectiles.splice(i,1); continue; }
    p.x+=p.vx*dt; p.y+=p.vy*dt;
    if(p.type==='laser'){
      const dSeg=10; const d=Math.hypot(p.vx,p.vy)||1; const ux=p.vx/d, uy=p.vy/d; const L=p.beamLen;
      for(let s=0;s<=L; s+=dSeg){ const px=p.x+ux*s, py=p.y+uy*s; if(px>enemy.x && px<enemy.x+enemy.w && py>enemy.y && py<enemy.y+enemy.h){ damageEnemy(4); break; } }
    } else if(p.type==='fire'){
      if(p.x>enemy.x && p.x<enemy.x+enemy.w && p.y>enemy.y && p.y<enemy.y+enemy.h){ damageEnemy(6); enemy.burnT=Math.min(enemy.burnT+800,2500); projectiles.splice(i,1); }
    } else if(p.type==='iceball'){
      if(p.x>enemy.x && p.x<enemy.x+enemy.w && p.y>enemy.y && p.y<enemy.y+enemy.h){ damageEnemy(3); enemy.fxFreeze=Math.max(enemy.fxFreeze, 800); projectiles.splice(i,1); }
    } else if(p.type==='karate'){
      if(p.x>enemy.x-6 && p.x<enemy.x+enemy.w+6 && p.y>enemy.y && p.y<enemy.y+enemy.h){ damageEnemy(8); projectiles.splice(i,1);} 
    }
  }
  if(enemy.burnT>0){ enemy.burnT-=dt; if(Math.random()<0.03) damageEnemy(0.7); }

  // HUD & end
  hpYou.style.width=Math.max(0,player.hp)+'%';
  hpE.style.width=Math.max(0,enemy.hp)+'%';
  if(player.hp<=0){ player.hp=0; running=false; overlayMsg('Lost! Try again!'); return; }
  if(enemy.hp<=0){ enemy.hp=0; running=false; overlayMsg('You Win!'); return; }
}

function damageEnemy(d){ enemy.hp=Math.max(0, enemy.hp - d); }
function damagePlayer(d){ player.hp=Math.max(0, player.hp - d); }

// ===== Powers
function activatePower(){
  if(!running) return;
  switch(currentPower){
    case 'laser':{
      const sx=player.x+player.w/2, sy=player.y+player.h/2; const ex=enemy.x+enemy.w/2, ey=enemy.y+enemy.h/2; const dx=ex-sx, dy=ey-sy; const d=Math.hypot(dx,dy)||1;
      const vx=(dx/d)*projectileSpeed, vy=(dy/d)*projectileSpeed;
      projectiles.push({type:'laser',x:sx,y:sy,vx,vy,ttl:300,beamLen:140});
      break;}
    case 'ice':{
      // Freeze pulse if close, plus an iceball projectile regardless
      const cx=player.x+player.w/2, cy=player.y+player.h/2; const ex=enemy.x+enemy.w/2, ey=enemy.y+enemy.h/2; const dx=ex-cx, dy=ey-cy; const d=Math.hypot(dx,dy)||1;
      if(d<200){ enemy.fxFreeze=Math.max(enemy.fxFreeze,1200); damageEnemy(2); }
      const vx=(dx/d)*projectileSpeed, vy=(dy/d)*projectileSpeed; // launched iceball
      projectiles.push({type:'iceball',x:cx,y:cy,vx,vy,ttl:2800});
      break;}
    case 'fire':{
      const sx=player.x+player.w/2, sy=player.y+player.h/2; const ex=enemy.x+enemy.w/2, ey=enemy.y+enemy.h/2; const dx=ex-sx, dy=ey-sy; const d=Math.hypot(dx,dy)||1;
      const vx=(dx/d)*projectileSpeed, vy=(dy/d)*projectileSpeed;
      projectiles.push({type:'fire',x:sx,y:sy,vx,vy,ttl:3000});
      break;}
    case 'invis':{ player.inv=true; player.invT=1000; break; }
    case 'karate':{
      const sx=player.x+player.w/2, sy=player.y+player.h/2; const ex=enemy.x+enemy.w/2, ey=enemy.y+enemy.h/2; const dx=ex-sx, dy=ey-sy; const d=Math.hypot(dx,dy)||1; const reach=Math.min(40,d);
      const jx=sx+(dx/d)*reach, jy=sy+(dy/d)*reach; projectiles.push({type:'karate',x:jx,y:jy,vx:0,vy:0,ttl:160});
      break;}
  }
}

// ===== Game flow
function reset(startNow=false){
  // stats
  Object.assign(player,{x:100,y:300,hp:100,inv:false,invT:0,stunT:0,nextHitAt:0,clickTarget:null,speed:playerBaseSpeed});
  Object.assign(enemy ,{x:680,y:300,hp:100,fxFreeze:0,stunT:0,burnT:0,speed:enemyBaseSpeed});
  projectiles.length=0; items.length=0; hazards.length=0;
  hpYou.style.width='100%'; hpE.style.width='100%';
  if(startNow){ started=true; running=true; startAt=performance.now(); startBtn.style.display='none'; restartBtn.style.display='inline-block'; scheduleApple(startAt); scheduleHammer(startAt); }
  else { started=false; running=false; startBtn.style.display='inline-block'; restartBtn.style.display='none'; }
}

window.addEventListener('keydown',e=>{ if(e.key==='r'||e.key==='R'){ reset(true); }});

function loop(ts){ if(!lastAnim) lastAnim=ts; const dt=Math.min(32, ts-lastAnim); lastAnim=ts; update(dt); requestAnimationFrame(loop); }
reset(false); updatePowerUI(); requestAnimationFrame(loop);
</script>
</body>
</html>
